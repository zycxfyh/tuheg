name: Staging Deployment

on:
  push:
    branches: [develop]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if checks fail'
        required: false
        default: false
        type: boolean

concurrency:
  group: staging-deployment
  cancel-in-progress: true

jobs:
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Verify deployment readiness
        run: |
          # Check if all required workflows passed
          echo "Checking workflow statuses..."

          # Get recent workflow runs
          WORKFLOWS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs?per_page=10" | \
            jq -r '.workflow_runs[] | select(.head_sha == "${{ github.sha }}") | .conclusion')

          FAILED_WORKFLOWS=0
          for status in $WORKFLOWS; do
            if [ "$status" = "failure" ]; then
              FAILED_WORKFLOWS=$((FAILED_WORKFLOWS + 1))
            fi
          done

          if [ "$FAILED_WORKFLOWS" -gt 0 ] && [ "${{ github.event.inputs.force_deploy }}" != "true" ]; then
            echo "‚ùå $FAILED_WORKFLOWS workflow(s) failed. Use force_deploy=true to override."
            exit 1
          fi

          echo "‚úÖ Pre-deployment checks passed"

  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: pre-deployment-checks
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9.6.0

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build applications
        run: pnpm build

      - name: Run smoke tests
        run: |
          # Quick smoke tests before deployment
          pnpm test -- --testPathPattern="smoke" --passWithNoTests
        env:
          NODE_ENV: test

      - name: Generate build artifacts
        run: |
          mkdir -p build-artifacts
          cp -r apps/*/dist build-artifacts/ 2>/dev/null || true
          cp -r packages/*/dist build-artifacts/packages/ 2>/dev/null || true
          cp package.json build-artifacts/
          cp pnpm-lock.yaml build-artifacts/

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: staging-build-${{ github.sha }}
          path: build-artifacts/
          retention-days: 7

  deploy-to-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: build-and-test
    environment: staging

    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: staging-build-${{ github.sha }}
          path: build-artifacts/

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          username: ${{ secrets.CONTAINER_REGISTRY_USERNAME }}
          password: ${{ secrets.CONTAINER_REGISTRY_PASSWORD }}

      - name: Build and push backend images
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: true
          tags: |
            ${{ secrets.CONTAINER_REGISTRY }}/backend-gateway:${{ github.sha }}
            ${{ secrets.CONTAINER_REGISTRY }}/backend-gateway:staging
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=staging

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: apps/frontend
          file: apps/frontend/Dockerfile
          push: true
          tags: |
            ${{ secrets.CONTAINER_REGISTRY }}/frontend:${{ github.sha }}
            ${{ secrets.CONTAINER_REGISTRY }}/frontend:staging
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Deploy to staging environment
        run: |
          # Use kubectl or your deployment tool
          echo "Deploying to staging environment..."

          # Update deployment manifests with new image tags
          sed -i "s|image:.*backend-gateway.*|image: ${{ secrets.CONTAINER_REGISTRY }}/backend-gateway:${{ github.sha }}|g" deployment/k8s/staging/backend-gateway-deployment.yaml
          sed -i "s|image:.*frontend.*|image: ${{ secrets.CONTAINER_REGISTRY }}/frontend:${{ github.sha }}|g" deployment/k8s/staging/frontend-deployment.yaml

          # Apply Kubernetes manifests
          kubectl apply -f deployment/k8s/staging/ --namespace staging

          # Wait for rollout to complete
          kubectl rollout status deployment/backend-gateway --namespace staging --timeout=300s
          kubectl rollout status deployment/frontend --namespace staging --timeout=300s

        env:
          KUBECONFIG: ${{ secrets.KUBECONFIG_STAGING }}

  staging-health-check:
    name: Staging Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: deploy-to-staging
    environment: staging

    steps:
      - name: Wait for application startup
        run: |
          echo "Waiting for staging environment to be ready..."
          for i in {1..30}; do
            if curl -f -s "${{ secrets.STAGING_URL }}/health" > /dev/null; then
              echo "‚úÖ Staging environment is healthy"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 10
          done

          if [ $i -eq 30 ]; then
            echo "‚ùå Staging environment failed to start"
            exit 1
          fi

      - name: Run staging smoke tests
        run: |
          npm install -g newman

          # Run Postman collection against staging
          newman run scripts/staging-smoke-tests.postman_collection.json \
            --environment scripts/staging.postman_environment.json \
            --reporters cli,json \
            --reporter-json-export staging-test-results.json

        env:
          STAGING_URL: ${{ secrets.STAGING_URL }}
          STAGING_API_URL: ${{ secrets.STAGING_API_URL }}

      - name: Upload staging test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: staging-test-results-${{ github.run_id }}
          path: |
            staging-test-results.json
          retention-days: 7

  notify-deployment:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [deploy-to-staging, staging-health-check]
    if: always()
    environment: staging

    steps:
      - name: Generate deployment summary
        run: |
          echo "## üöÄ Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** Staging" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed at:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Deployment status
          if [ "${{ needs.deploy-to-staging.result }}" == "success" ]; then
            echo "‚úÖ Deployment: Successful" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Deployment: Failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Health check status
          if [ "${{ needs.staging-health-check.result }}" == "success" ]; then
            echo "‚úÖ Health Check: Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Health Check: Failed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Links" >> $GITHUB_STEP_SUMMARY
          echo "- [Staging Environment](${{ secrets.STAGING_URL }})" >> $GITHUB_STEP_SUMMARY
          echo "- [API Documentation](${{ secrets.STAGING_API_DOCS_URL }})" >> $GITHUB_STEP_SUMMARY

      - name: Send deployment notification
        run: |
          # Send notification to Slack, Teams, etc.
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"üöÄ Staging deployment completed\",
              \"blocks\": [
                {
                  \"type\": \"section\",
                  \"text\": {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*Staging Deployment Completed*\nCommit: ${{ github.sha }}\nStatus: ${{ needs.deploy-to-staging.result == 'success' && '‚úÖ Success' || '‚ùå Failed' }}\"
                  }
                },
                {
                  \"type\": \"actions\",
                  \"elements\": [
                    {
                      \"type\": \"button\",
                      \"text\": {
                        \"type\": \"plain_text\",
                        \"text\": \"View Staging\"
                      },
                      \"url\": \"${{ secrets.STAGING_URL }}\"
                    }
                  ]
                }
              ]
            }" \
            ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create deployment record
        run: |
          # Record deployment in your deployment tracking system
          echo "Recording deployment in tracking system..."
          # This could integrate with tools like DeployHub, Azure DevOps, etc.
