{"file":"C:\\Users\\16663\\Desktop\\tuheg\\packages\\common-backend\\src\\reactive\\event-stream.ts","mappings":"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","names":[],"sources":["C:\\Users\\16663\\Desktop\\tuheg\\packages\\common-backend\\src\\reactive\\event-stream.ts"],"sourcesContent":["// 文件路径: packages/common-backend/src/reactive/event-stream.ts\n// 核心理念: 响应式数据流，使用 Observable 处理异步事件\n\nimport { Injectable, Logger } from '@nestjs/common'\nimport { catchError, mergeMap, type Observable, Subject } from 'rxjs'\n\n/**\n * @interface EventStreamConfig\n * @description 事件流配置\n */\nexport interface EventStreamConfig {\n  /** 事件名称 */\n  eventName: string\n  /** 是否自动重试 */\n  autoRetry?: boolean\n  /** 最大重试次数 */\n  maxRetries?: number\n  /** 重试延迟（毫秒） */\n  retryDelay?: number\n}\n\n/**\n * @class EventStream\n * @description RxJS 风格的事件流处理器\n * 用于处理异步事件流，支持操作符组合和错误处理\n */\n@Injectable()\nexport class EventStream {\n  private readonly logger = new Logger(EventStream.name)\n  private readonly streams = new Map<string, Subject<any>>()\n\n  /**\n   * @method createStream\n   * @description 创建事件流\n   */\n  public createStream<T = unknown>(eventName: string): Observable<T> {\n    if (!this.streams.has(eventName)) {\n      this.streams.set(eventName, new Subject<any>())\n    }\n\n    return this.streams.get(eventName) as Observable<T>\n  }\n\n  /**\n   * @method emit\n   * @description 发送事件到流\n   */\n  public emit<T = unknown>(eventName: string, data: T): void {\n    const stream = this.streams.get(eventName)\n    if (stream) {\n      stream.next(data)\n      this.logger.debug(`Emitted event \"${eventName}\"`)\n    } else {\n      this.logger.warn(`Stream \"${eventName}\" not found`)\n    }\n  }\n\n  /**\n   * @method subscribe\n   * @description 订阅事件流\n   */\n  public subscribe<T = unknown>(\n    eventName: string,\n    handler: (data: T) => void | Promise<void>,\n    config?: EventStreamConfig\n  ): () => void {\n    const stream = this.createStream<T>(eventName)\n\n    const subscription = stream.subscribe({\n      next: async (data) => {\n        try {\n          await handler(data)\n        } catch (error) {\n          this.logger.error(\n            `Error handling event \"${eventName}\":`,\n            error instanceof Error ? error.message : String(error)\n          )\n\n          if (config?.autoRetry) {\n            await this.retryHandler(eventName, handler, data, config)\n          }\n        }\n      },\n      error: (error) => {\n        this.logger.error(\n          `Stream error for \"${eventName}\":`,\n          error instanceof Error ? error.message : String(error)\n        )\n      },\n    })\n\n    return () => subscription.unsubscribe()\n  }\n\n  /**\n   * @method pipe\n   * @description 管道操作符（简化版）\n   */\n  public pipe<T, R>(eventName: string, transform: (data: T) => R | Promise<R>): Observable<R> {\n    const stream = this.createStream<T>(eventName)\n\n    return stream.pipe(\n      mergeMap(async (data) => {\n        try {\n          return await transform(data)\n        } catch (error) {\n          this.logger.error(\n            `Error in pipe for \"${eventName}\":`,\n            error instanceof Error ? error.message : String(error)\n          )\n          throw error\n        }\n      }),\n      catchError((error) => {\n        this.logger.error(\n          `Pipe error for \"${eventName}\":`,\n          error instanceof Error ? error.message : String(error)\n        )\n        throw error\n      })\n    )\n  }\n\n  /**\n   * @method retryHandler\n   * @description 重试处理器\n   */\n  private async retryHandler<T>(\n    eventName: string,\n    handler: (data: T) => void | Promise<void>,\n    data: T,\n    config: EventStreamConfig\n  ): Promise<void> {\n    const maxRetries = config.maxRetries ?? 3\n    const retryDelay = config.retryDelay ?? 1000\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      await new Promise((resolve) => setTimeout(resolve, retryDelay * attempt))\n\n      try {\n        await handler(data)\n        this.logger.log(`Successfully retried event \"${eventName}\" after ${attempt} attempts`)\n        return\n      } catch (error) {\n        if (attempt === maxRetries) {\n          this.logger.error(\n            `Failed to handle event \"${eventName}\" after ${maxRetries} attempts`,\n            error instanceof Error ? error.message : String(error)\n          )\n          throw error\n        }\n      }\n    }\n  }\n\n  /**\n   * @method close\n   * @description 关闭事件流\n   */\n  public close(eventName: string): void {\n    const stream = this.streams.get(eventName)\n    if (stream) {\n      stream.complete()\n      this.streams.delete(eventName)\n      this.logger.debug(`Closed stream \"${eventName}\"`)\n    }\n  }\n\n  /**\n   * @method closeAll\n   * @description 关闭所有事件流\n   */\n  public closeAll(): void {\n    for (const [eventName, stream] of this.streams.entries()) {\n      stream.complete()\n      this.logger.debug(`Closed stream \"${eventName}\"`)\n    }\n    this.streams.clear()\n  }\n}\n"],"version":3}