a370c864bc2440168d9d83a8aae3636c
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatZodError = formatZodError;
exports.formatZodErrorAsJson = formatZodErrorAsJson;
const zod_1 = require("zod");
function formatZodError(error) {
    const inputData = error.data;
    const fieldErrors = [];
    for (const issue of error.issues) {
        const path = issue.path.length > 0 ? issue.path.join('.') : 'root';
        let expected = 'unknown';
        if (issue.code === zod_1.z.ZodIssueCode.invalid_type) {
            expected = issue.expected;
        }
        else if (issue.code === zod_1.z.ZodIssueCode.invalid_enum_value) {
            expected = `one of: ${issue.options.join(', ')}`;
        }
        else if (issue.code === zod_1.z.ZodIssueCode.too_small) {
            if (issue.type === 'array') {
                expected = `array with at least ${issue.minimum} items`;
            }
            else if (issue.type === 'string') {
                expected = `string with at least ${issue.minimum} characters`;
            }
            else if (issue.type === 'number') {
                expected = `number >= ${issue.minimum}`;
            }
        }
        else if (issue.code === zod_1.z.ZodIssueCode.too_big) {
            if (issue.type === 'array') {
                expected = `array with at most ${issue.maximum} items`;
            }
            else if (issue.type === 'string') {
                expected = `string with at most ${issue.maximum} characters`;
            }
            else if (issue.type === 'number') {
                expected = `number <= ${issue.maximum}`;
            }
        }
        else if (issue.code === zod_1.z.ZodIssueCode.invalid_string) {
            expected = `valid ${issue.validation} string`;
        }
        let received;
        if (issue.path.length > 0 && inputData !== undefined) {
            try {
                const receivedValue = issue.path.reduce((obj, key) => {
                    if (typeof obj === 'object' && obj !== null && key in obj) {
                        return obj[key];
                    }
                    return undefined;
                }, inputData);
                if (receivedValue !== undefined) {
                    const receivedStr = JSON.stringify(receivedValue);
                    received = receivedStr.length > 100 ? `${receivedStr.slice(0, 100)}...` : receivedStr;
                }
            }
            catch {
            }
        }
        fieldErrors.push({
            path,
            expected,
            received,
            message: issue.message,
        });
    }
    const uniquePaths = Array.from(new Set(fieldErrors.map((e) => e.path)));
    const summary = `Validation failed: ${error.issues.length} error(s) found. ` +
        `Fields with errors: ${uniquePaths.join(', ')}`;
    const aiFeedback = generateAiFeedback(fieldErrors);
    return {
        summary,
        fieldErrors,
        aiFeedback,
    };
}
function generateAiFeedback(fieldErrors) {
    if (fieldErrors.length === 0) {
        return 'No validation errors found.';
    }
    const sections = [];
    sections.push('**Validation Errors Detected:**');
    sections.push('');
    const errorsByField = new Map();
    for (const error of fieldErrors) {
        const existing = errorsByField.get(error.path) || [];
        existing.push(error);
        errorsByField.set(error.path, existing);
    }
    for (const [path, errors] of Array.from(errorsByField.entries())) {
        sections.push(`**Field: ${path}**`);
        for (const error of errors) {
            sections.push(`- Expected: ${error.expected}`);
            if (error.received !== undefined) {
                sections.push(`- Received: ${error.received}`);
            }
            sections.push(`- Issue: ${error.message}`);
        }
        sections.push('');
    }
    sections.push('**Action Required:**');
    sections.push('Please fix the above errors and regenerate the JSON output. ' +
        'Ensure all required fields are present, types are correct, and values meet the constraints.');
    return sections.join('\n');
}
function formatZodErrorAsJson(formattedError) {
    return JSON.stringify({
        summary: formattedError.summary,
        fieldErrors: formattedError.fieldErrors,
        errorCount: formattedError.fieldErrors.length,
    }, null, 2);
}
//# sourceMappingURL=schema-error-formatter.js.map